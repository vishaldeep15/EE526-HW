clc,clear
n=26; a=zeros(n);
a(1,2)=5;a(1,3)=6;a(1,4)=4;a(1,5)=7;
a(2,6)=2;a(2,7)=3;
a(3,6)=6;a(3,7)=4;a(3,8)=1;
a(4,7)=7;a(4,8)=3;a(4,9)=6;
a(5,8)=9;a(5,9)=1;
a(6,10)=2;a(6,11)=3;
a(7,10)=6;a(7,11)=4;a(7,12)=1;
a(8,11)=7;a(8,12)=3;a(8,13)=6;
a(9,12)=9;a(9,13)=7;
a(10,14)=2;a(10,15)=3;
a(11,14)=6;a(11,15)=4;a(11,16)=1;
a(12,15)=7;a(12,16)=10;a(12,17)=6;
a(13,16)=9;a(13,17)=8;
a(14,18)=2;a(14,19)=3;
a(15,18)=6;a(15,19)=4;a(15,20)=1;
a(16,19)=7;a(16,20)=3;a(16,21)=6;
a(17,20)=9;a(17,21)=1;
a(18,22)=2;a(18,23)=3;
a(19,22)=6;a(19,23)=4;a(19,24)=1;
a(20,23)=7;a(20,24)=3;a(20,25)=6;
a(21,24)=9;a(21,25)=1;
a(22,26)=5;
a(23,26)=6;
a(24,26)=4;
a(25,26)=7;


a=a+a';

a(a==0)=inf; %为方便，将对角线上的元素和没有连线的路用inf表达二者距离
% a=-a;

pb(1:n)=0; pb(1)=1;  %当一个点已经求出到原点的最短距离时，其下标i对应的pb(i)赋1
index1=1 ;           %存放存入S集合的顺序
index2=ones(1,n);    %存放始点到第i点最短通路中第i顶点前一顶点的序号
d(1:n)=inf;   %存放由始点到第i点最短通路的值
d(1)=0;       %本次起始点是1，故d=0
temp=1;       %表示起始点

while sum(pb)<n %是否所有的点都被标记了
    tb=find(pb==0); %找到为0的值，表示未在集合S中
    d(tb)=min(d(tb),d(temp)+a(temp,tb));%计算标号为0的最短路，计算公式在开头图中给出
    tmpb=find(d(tb)==min(d(tb)));%找到d[tb]最小值的下标
    temp=tb(tmpb(1));%可能存在多个最小值，只取一个，并且此时的原点也会变为下一个原点
    pb(temp)=1;% 找到最小路，打上标记
    index1=[index1,temp];%将打上标记的存入S集合中
    temp2=find(d(index1)==d(temp)-a(temp,index1));%最小路径
    index2(temp)=index1(temp2(1));%记录标号索引①

end
% d,index1,index2%
i=zeros(1,n); 
i(1)=n;  %逆推法，从最后一项开始

for j=2:n
    i(j)=index2(i(j-1));  
    if i(j)==1
        break
    end
end
i=i(i~=0);  %去除非0元素
for  ii=length(i):-1:1 %倒着输出
    if ii~=length(i)
    fprintf('-->')
    end
    fprintf('v(%d)',i(ii))
end
fprintf('\n') 